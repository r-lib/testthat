---
title: "Testing challenging functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Testing challenging functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
#| include: false
library(testthat)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")

# Pretend we're snapshotting
snapper <- local_snapshotter(fail_on_new = FALSE)
snapper$start_file("snapshotting.Rmd", "test")

# Pretend we're testing testthat so we can use mocking
Sys.setenv(TESTTHAT_PKG = "testthat")
```

Index to tools to solving challenging problems, organised by the problem, not the technique used to solve it. Designed to short so you can skim the whole thing, spot the problem your facing, and then see the tools you can use to solve it. 

## Options and environment variables

In this case can temporarily override with withr functions:

* Temporarily change options with `withr::local_options()`.
* Temporarily change env vars with `withr::local_envvar()`.

`vignette("test-fixtures")`

## HTTP requests

* If you need to test HTTP requests, we recommend using {vcr} or {httptest2}.

## User interaction

Mock away the function that the user returns.

`vignette("mocking")`

For example, if your code uses `readline` to get feedback from the user, you can mock it. This is a good place to `mock_output_sequence()` if you want to simulate the user answering multiple questions.

```{r}
readline <- NULL

continue <- function() {
  repeat{
   val <- readline("Do you want to continue? (y/n) ")
   if (val %in% c("y", "n")) {
     return(val == "y")
   }
   cat("! You must enter y or n\n")
  }  
}

test_that("user must respond y or n", {
  mock_readline <- local({
    i <- 0
    function(prompt) {
      i <<- i + 1
      cat(prompt)
      val <- if (i == 1) "x" else "y"
      cat(val, "\n", sep = "")
      val
    }
  })

  local_mocked_bindings(readline = mock_readline)
  expect_snapshot(val <- continue())
  expect_true(val)
})
```

## Random numbers

Random number generation is a special case of test fixures (`vignette("test-fixtures")`) on the value of the special `.Random.seed` variable which is updated whenever you generate a random number. You can temporarily change this seed and reproducibly generate "random" numbers with `withr::local_seed()`.

```{r}
dice <- function() {
  sample(6, 1)
}

test_that("dice returns different numbers", {
  withr::local_seed(1234)

  expect_equal(dice(), 4)
  expect_equal(dice(), 2)
  expect_equal(dice(), 6)
})
```

## Errors

Errors, warnings, and other user-facing text should be tested to ensure they're helpful and consistent. Obviously you can't test this 100% automatically, but you can ensure that such messaging is clearly shown in PRs, so another human can take a look. This is exactly the point of snapshot tests.

Test with snapshot tests: `vignette("snapshotting")`.

## Testing interfaces

Sometimes you want to ensure multiple functions obey the same interface (e.g. they have the same arguments, or all error in the same way). You can use nested tests for this: see `vignette("nested-tests")`.
