---
title: "Custom expectations"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Custom expectations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(testthat)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")

# Pretend we're snapsotting
snapper <- local_snapshotter()
snapper$start_file("snapshotting.Rmd", "test")
```

This vignette shows you how to write your expectations. You can use within your package by putting them in a helper file, or share them with others by exporting them from your package.

## Expectation basics

An expectation has three main parts, as illustrated by `expect_length()`:

```{r}
expect_length <- function(object, n) {  
  # 1. Capture object and label
  act <- quasi_label(rlang::enquo(object), arg = "object")

  # 2. Fail when expectations aren't met
  act_n <- length(act$val)
  if (act_n != n) {
    msg <- sprintf("%s has length %i, not length %i.", act$lab, act_n, n)
    return(fail(msg))
  }
  
  # 3. Pass when expectations are
  pass(act$val)
}
```

The first step in any expectation is to use `quasi_label()` to capture a "labelled value", i.e. an list that contains both the value (`$val`) for testing and a label (`$lab`) for messaging. This is a pattern that exists for fairly esoteric reasons; you don't need to understand, just copy and paste it ðŸ™‚.

Next you need to check each way that `object` could be broken. In most cases, it's easier to check for problems one by one, using early returns to `fail()` when any expectation is violated as that makes it easier to write failure messages. It's good practice to state both what the object is and what you expected in your failures.

Also note that you need to use `return(fail())` here. You won't see the problem when interactively testing your function because when run outside of `test_that()`, `fail()` throws an error, causing the function to terminate early. When running inside of `test_that()`, however, `fail()` does not stop execution because we want to collect all failures in a given test.  

Finally, if the object is as expected, call `pass()` with `act$val`. Returning the input value is good practice since expectation functions are called primarily for their side-effects (triggering a failure). This allows expectations to be chained:

```{r}
mtcars |>
  expect_type("list") |>
  expect_s3_class("data.frame") |> 
  expect_length(11)
```

### Testing your expectations

Once you've written your expectation, you need to test it, and luckily testthat comes with three expectations designed specifically to test expectations:

* `expect_success()` checks that your expectation emits exactly one success and zero failures.
* `expect_failure()` checks that your expectation emits exactly one failure and zero successes. 
* `expect_failure_snapshot()` captures the failure message in a snapshot, making it easier to review if it's useful or not.

The first two expectations are particularly important because they ensure that your expectation reports the correct number of succeses and failures to the user.

```{r}
test_that("expect_length works as expected", {
  x <- 1:10
  expect_success(expect_length(x, 10))
  expect_failure(expect_length(x, 11))
})

test_that("expect_length gives useful feedback", {
  x <- 1:10
  expect_snapshot_failure(expect_length(x, 11))
})
```

## Examples

The following sections show you a few more variations, losely based on existing testthat expectations.

### `expect_vector_length()`

Lets make `expect_length()` a bit more strict by also checking that the input is a vector. R is a bit weird that it gives a length to pretty much every object, and you can imagine not wanting this code to succeed:

```{r}
expect_length(mean, 1)
```

To do this we'll add an extra check that the input is either an atomic vector or a list:

```{r}
expect_vector_length <- function(object, n) {  
  act <- quasi_label(rlang::enquo(object))

  if (!is.atomic(act$val) && !is.list(act$val)) {
    msg <- sprintf("%s is a %s, not a vector", act$lab, typeof(act$val))
    return(fail(msg))
  }

  act_n <- length(act$val)
  if (act_n != n) {
    msg <- sprintf("%s has length %i, not length %i.", act$lab, act_n, n)
    return(fail(msg))
  }
  
  pass(act$val)
}
```

```{r}
#| error: true
expect_vector_length(mean, 1)
expect_vector_length(mtcars, 15)
```

### `expect_s3_class()`

Or imagine if you're checking to see if an object inherits from an S3 class. In R, there's no direct way to tell if an object is an S3 object: you can confirm that it's an object, then that it's not an S4 object. So you might organise your expectation this way:

```{r}
expect_s3_class <- function(object, class) {
  act <- quasi_label(rlang::enquo(object), arg = "object")

  if (!is.object(act$val)) {
    return(fail(sprintf("%s is not an object.", act$lab)))
  }

  if (isS4(act$val)) {
    return(fail(sprintf("%s is an S4 object, not an S3 object.", act$lab)))
  }

  if (!inherits(act$val, class)) {
    msg <- sprintf(
      "%s inherits from %s not %s.",
      act$lab,
      paste0(class(object), collapse = "/"),
      paste0(class, collapse = "/")
    )
    return(fail(msg))
  }

  pass(act$val)
}
```

```{r}
#| error: true
x1 <- 1:10
TestClass <- methods::setClass("Test", contains = "integer")
x2 <- TestClass()
x3 <- factor()

expect_s3_class(x1, "integer")
expect_s3_class(x2, "integer")
expect_s3_class(x3, "integer")
```

## Repeated code

As you write more expectations, you might discover repeated code that you want to extract out in to a helper. For example, testthat has `expect_true()`, `expect_false()`, and `expect_null()` which are special cases of `expect_equal()`. 

```{r}
expect_true <- function(object) {
  act <- quasi_label(enquo(object))
  expect_waldo_equal_("equal", act, TRUE, ignore_attr = TRUE)
}
expect_false <- function(object) {
  act <- quasi_label(enquo(object))
  expect_waldo_equal_("equal", act, FALSE, ignore_attr = TRUE)
}
expect_null <- function(object, label = NULL) {
  act <- quasi_label(enquo(object))
  expect_waldo_equal_("equal", act, NULL)
}
```

You might wonder why these functions don't call `expect_equal()` directly. Unfortunately creating helper functions is not straightforward in testthat because every `fail()` captures the calling environment in order to give maximally useful tracebacks. Getting this right is not critical (you'll just get a slightly suboptimal traceback in the case of failure) but it's good practice, particularly for testthat itself.

To do things 100% correctly, in your helper function you need to have a `trace_env` argument that defaults to `caller_env()`, and then you need to pass it to every instance of 

```{r}
expect_waldo_equal_ <- function(
  type,
  act,
  exp,
  info,
  ...,
  trace_env = caller_env()
) {
  comp <- waldo_compare(
    act$val,
    exp$val,
    ...,
    x_arg = "actual",
    y_arg = "expected"
  )
  if (length(comp) != 0) {
    msg <- sprintf(
      "%s (%s) not %s to %s (%s).\n\n%s",
      act$lab,
      "`actual`",
      type,
      exp$lab,
      "`expected`",
      paste0(comp, collapse = "\n\n")
    )
    return(fail(msg, info = info, trace_env = trace_env))
  }
  pass(act$val)
}

```
