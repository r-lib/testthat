% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mock2.R
\name{local_mocked_bindings}
\alias{local_mocked_bindings}
\alias{with_mocked_bindings}
\title{Mocking tools}
\usage{
local_mocked_bindings(..., .package = NULL, .env = caller_env())

with_mocked_bindings(code, ..., .package = NULL)
}
\arguments{
\item{...}{Name-value pairs providing functions to mock.}

\item{.package}{The name of the package where mocked functions should be
inserted. Generally, you should not need to supply this as it will be
automatically detected when whole package tests are run or when there's
one package under active development (i.e. loaded with
\code{\link[pkgload:load_all]{pkgload::load_all()}}).}

\item{.env}{Environment that defines effect scope. For expert use only.}

\item{code}{Code to execute with specified bindings.}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

These functions represent a second attempt at bringing mocking to testthat,
incorporating what we've learned from the mockr, mockery, and mockthat package.

\code{with_mocked_bindings()} and \code{local_mocked_bindings()} work by temporarily
changing variable bindings in the namespace of namespace \code{.package}.
Generally, it's only safe to mock packages that you own. If you mock other
packages, we recommend using \code{skip_on_cran()} to avoid CRAN failures if the
implementation changes.

These functions do not currently affect registered S3 methods.
}
\section{Use}{
There are three places that the function you are trying to mock might
come from: inside your package, imported from an external package via
the \code{NAMESPACE}, called from an external package with \code{::}. The first
two cases you can mock the same way. For example, take this code:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{function_to_mocked <- function() \{
  another_function()
\}
}\if{html}{\out{</div>}}

It doesn't matter whether you wrote \code{another_function()} or you've
imported it from another package with \verb{@import} or \verb{@importFrom},
you mock it the same way:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{local_mocked_bindings(
  another_function = function(...) "new_value"
)
}\if{html}{\out{</div>}}

It's hard to mock functions in other packages that you call with \code{::}.
For example, take this minor variation:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{function_to_mocked <- function() \{
  anotherpackage::another_function()
\}
}\if{html}{\out{</div>}}

To mock here, you'll need to modify \code{another_function()} inside the
\code{anotherpackage} package. You \emph{can} do this by supplying the \code{.package}
argument:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{local_mocked_bindings(
  another_function = function(...) "new_value",
  .package = "anotherpackage"
)
}\if{html}{\out{</div>}}

But it's not great to modify a namespace that you don't own. Instead
you can either import the function into your package, or you can make
a wrapper funtion that you can mock:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{function_to_mocked <- function() \{
  my_wrapper()
\}
my_wrapper <- function(...) \{
  anotherpackage::another_function()
\}

local_mocked_bindings(
  my_wrapper = function(...) "new_value"
)
}\if{html}{\out{</div>}}
}

