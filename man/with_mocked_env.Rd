% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mock2.R
\name{with_mocked_env}
\alias{with_mocked_env}
\alias{with_mocked_bindings}
\alias{local_mocked_bindings}
\title{Mocking tools}
\usage{
with_mocked_env(f, ...)

with_mocked_bindings(code, ...)

local_mocked_bindings(..., .env = caller_env())
}
\arguments{
\item{f}{A function.}

\item{...}{Name-value pairs providing functions to mock.}

\item{code}{Code to execute with specified bindings.}

\item{.env}{Environment that defines effect scope. For expert use only.}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

These functions represent a second attempt at bringing mocking to testthat,
incorporating what we've learned from mockr and mockery There are
two styles of mocking:
\itemize{
\item \code{local_mocked_bindings()} and \code{local_mocked_bindings()} work by temporarily
changing variable bindings in the package namespace. It affects the
operation of every function in the current package, but only the current
package.
\item \code{with_mocked_env()} modifies a function, inserting a new environment in the
chain of parents with the specified bindings. It can mock any function,
but because it creates a new function, it doesn't affect any functions
that use that function.
}
}
